
(define (inc n f x) (f (n f x)))

(\inc code) (\n \f \x (f (n f x))


(define (sum n m f x) (n f (m f x)))
(define (product n m f x) (n (m f) x))

(define (zero f x) x)
(define (one f x) (f x))
(define (two f x) (f (f x)))
(define three (inc two))
(define four (inc three))
(define five (inc four))
(define six (inc five))
(define seven (inc six))
(define eight (inc seven))
(define nine (inc eight))

(equal (sum five three) eight)
(equal (product two three) six)

(equal (sum five three) eight)
((equal ((sum five) three)) eight)

(sum five three)

(((\x (\y x)) y) z)

(\x \y x) y z

(\x \k x) y z
(\k y) z
y

\x \y x
x -> (y -> x)
every variable free when first created?
makeAbstraction goes through and binds any variables with matching name
makeAbstraction(variableName, body)

reduction
find the variable instances in the body of the abstraction that correspond
to the outermost abstraction
make a new expression with those variables

(lam x body)